### Code for Shiny widget
###
###
### Make this into an interactive visualization
###
library(shiny)
library(colourpicker)
# Define UI
ui <- fluidPage(
titlePanel("Interactive Network Plot"),
sidebarLayout(
sidebarPanel(
selectInput("selected_node",
"Choose a node to highlight:",
choices = NULL,  # Will be populated server-side
selected = NULL),
hr(),
h4("Options:"),
colourInput("highlight_color", "Highlight Color:", value = "#FF0000", showColour = "background"),
colourInput("default_color", "Default Color:", value = "#ADD8E6", showColour = "background"),
numericInput("highlight_size", "Highlight Size:", value = 8, min = 1, max = 20),
numericInput("default_size", "Default Size:", value = 4, min = 1, max = 20),
checkboxInput("color_by_rank", "Color all nodes by Rank", value = FALSE)
),
mainPanel(
plotOutput("network_plot", width = "100%", height = "600px")
)
)
)
# Define Server
server <- function(input, output, session) {
# Build network with name and rank attributes
shiny_network <- reactive({
g <- current_network
V(g)$name <- nodes$names
V(g)$rank <- nodes$JOBTITLE
return(g)
})
# Set fixed layout
network_layout <- reactive({
req(shiny_network())
layout_with_fr(shiny_network())
})
display_name_map <- reactive({
req(shiny_network())
internal <- V(shiny_network())$name
display <- str_to_title(internal)
names(internal) <- display
internal
})
# Update dropdown list of node names (capitalized & sorted)
observe({
req(shiny_network())
node_names <- V(shiny_network())$name
node_names_display <- node_names %>%
tolower() %>%
str_to_title() %>%
sort()
updateSelectInput(session, "selected_node",
choices = node_names_display,
selected = node_names_display[1])
})
# Main network plot
output$network_plot <- renderPlot({
req(shiny_network(), display_name_map())
g <- shiny_network()
layout <- network_layout()
vertex.size <- rep(input$default_size, vcount(g))
vertex.col <- rep(input$default_color, vcount(g))
main_title <- "Network"
# If coloring by rank
if (input$color_by_rank) {
ranks <- V(g)$rank
rank_levels <- unique(ranks)
pal <- viridis::viridis(length(rank_levels), option = "D")
names(pal) <- rank_levels
vertex.col <- pal[as.character(ranks)]
main_title <- "Network Colored by Officer Rank"
}
# If a node is selected, override its color/size
if (!is.null(input$selected_node) && input$selected_node %in% names(display_name_map())) {
selected_internal_name <- display_name_map()[[input$selected_node]]
selected_index <- which(V(g)$name == selected_internal_name)
vertex.col[selected_index] <- input$highlight_color
vertex.size[selected_index] <- input$highlight_size
selected_rank <- V(g)$rank[selected_index]
main_title <- paste0("Highlighting: ", input$selected_node,
" (Rank: ", selected_rank, ")")
}
# Create the plot
plot(g,
vertex.color = vertex.col,
vertex.size = vertex.size,
vertex.label = NA,
main = main_title,
edge.color = "gray",
layout = layout)
# Show rank legend only if coloring by rank
if (input$color_by_rank) {
legend("topleft",
legend = rank_levels,
fill = pal[rank_levels],
border = NA,
bty = "n",
title = "Officer Rank")
}
})
}
# Run the application
shinyApp(ui = ui, server = server)
#start clean
rm(list = ls())
#load libraries
library(tidyverse)
library(igraph)
library(ggraph)
library(here)
library(dplyr)
library(RColorBrewer)
library(readxl)
library(stringdist)
library(viridis)
###
### Formatting and Analysis of Roster Data
###
#read in full roster data, 2023-2025
mpd_roster_full <- read_excel(here("data/original/MPD_roster_2023-2025_Public.xlsx"))
#formatting names in officer roster
mpd_roster_full <- mpd_roster_full %>%
mutate(full_name = Name) %>%
separate(Name, into = c("last_name", "first_name"), sep = ",") %>%
mutate(
last_name = str_trim(last_name),
first_name = word(str_trim(first_name), 1)
) %>%
mutate(format_name = paste(first_name, last_name))
#lowercase all names in the roster for consistent comparison
mpd_roster_full <- mpd_roster_full %>%
mutate(
first_name = str_to_lower(first_name),
last_name = str_to_lower(last_name),
#remove hyphens and extra spaces
format_name = str_remove_all(str_to_lower(format_name), "-")
)
#officer that has two ids but the same name
name_id_counts <- mpd_roster_full %>%
group_by(format_name) %>%
summarise(num_ids = n_distinct(ID), .groups = "drop") %>%
filter(num_ids > 1)
#reformat this person to distinguish between the two ids-
#    this is done in the complaint data too
mpd_roster_full$format_name[which(mpd_roster_full$format_name ==
"matthew olson" &
mpd_roster_full$ID == "005305")] <-
"matthew olson (5305)"
mpd_roster_full$format_name[which(mpd_roster_full$format_name ==
"matthew olson" &
mpd_roster_full$ID == "005313")] <-
"matthew olson (5313)"
#total number of unique officers across the dataset
length(unique(mpd_roster_full$format_name))
#count of unique officers in 2023, 2024, 2025
num_off_per_year <- mpd_roster_full %>% group_by(Year) %>%
summarise(officers_unique = n_distinct(format_name))
#not using object after this point
rm(name_id_counts)
###
### Formatting of complaint data names
###
#load the web-scraped complaint data and the MPD Roster data
new_complaints <- read_csv(here('data/working/new_complaints.csv')) %>%
select(!`...1`)
#lowercase all names in the roster for consistent comparison
new_complaints <- new_complaints %>%
mutate(
format_name = str_to_lower(name),
format_name = str_remove_all(format_name, "-"),  #remove hyphens
format_name = str_squish(format_name)            #remove extra spaces
)
#manually correct spelling errors in new complaint data
new_complaints <- new_complaints %>%
mutate(
format_name = case_when(
format_name == "ariel lunasanchez" ~ "ariel luna sanchez",
format_name == "daniel oppergard" ~ "daniel oppegard",
format_name == "kelly o'rourke" ~ "kelly orourke",
format_name == "nicolas custode" ~ "nicholas custode",
format_name == "paul o'hanlon" ~ "paul ohanlon",
format_name == "timothy davis jr" ~ "timothy davis jr.",
format_name == "charlie adams" ~ "charles adams",
format_name == "scott aikins" ~ "scott aikins i",
format_name == "jeff werner" ~ "jeffrey werner",
format_name == "luke weatherspoon" ~ "lucas weatherspoon",
format_name == "craig crisp" ~ "craig crisp jr.",
format_name == "marjane khazraeinazm.." ~ "marjane khazraeinazmpour",
format_name == "richard walker" ~ "richard walker sr.",
format_name == "nicholas sciorrotta jr" ~ "nicholas sciorrotta jr jr.",
TRUE ~ format_name
)
)
###
### Preliminary analysis of complaint data:
###
#vector of unique officer names in full roster data
officer_names_roster <- unique(mpd_roster_full$format_name)
#vector of unique officer names in new complaint data
officer_names_complaint <- unique(new_complaints$format_name)
#how many of roster officer names appear in the new complaint dataset?
num_off_compl <- length(which(officer_names_roster %in%
new_complaints$format_name)) #406
#how many of complaint officer names appear in the roster dataset?
length(which(officer_names_complaint %in% mpd_roster_full$format_name)) #406
#what percent of roster officer names appear in the new complaint dataset?
perc_off_comp <- length(which(officer_names_roster %in%
new_complaints$format_name))/
length(officer_names_roster)*100 #61.6%
#what percent of complaint officer names appear in the roster dataset?
length(which(officer_names_complaint %in% mpd_roster_full$format_name))/
length(officer_names_complaint) #90.6%
#get the unmatched names from complaints (i.e., not in roster)
unmatched_complaint_names <-
officer_names_complaint[!(officer_names_complaint %in%
officer_names_roster)] #
#make a dataframe of complaint names not in the roster
unmatched_df <- tibble(unmatched_name = unmatched_complaint_names)
#find the closest match in the roster for each unmatched name
#these all appear to be true unmatches
unmatched_df <- unmatched_df %>%
rowwise() %>%
mutate(
closest_match =
officer_names_roster[which.min(stringdist(unmatched_name,
officer_names_roster))],
match_number = min(stringdist(unmatched_name, officer_names_roster))) %>%
ungroup()  %>%
arrange(match_number)
###
### Cleanup
rm(unmatched_df, unmatched_complaint_names)
#count number of officers per complaint
new_complaint_offcount <- new_complaints %>% count(complaint_id)
#subset the count data to those that have more than 1 officer involved
new_complaint_offcount_multiple <- new_complaint_offcount %>%
filter(n>1)
#subset the complaint data to only complaints with more than one officer
new_complaint_cos_only <-
new_complaints[which(new_complaints$complaint_id %in%
new_complaint_offcount_multiple$complaint_id),]
#how many officers on the roster are included in *co*-complaint
co_comp_off_num <- length(which(officer_names_roster %in%
new_complaint_cos_only$format_name)) #311
#what percent of these roster officer names appear in the co-complaint dataset?
co_comp_off_perc <- length(which(officer_names_roster %in%
new_complaint_cos_only$format_name))/
length(officer_names_roster) #47.19%
#filter complaint data to only those officers in the 2023-2025 rosters
final_complaints <- new_complaints %>% filter(format_name %in%
officer_names_roster)
#number of complaints per officer (including single complaints)
comp_per_off <- final_complaints %>% count(name)
mean(comp_per_off$n)
#distribution of comp per officers
p1 <- ggplot(data=comp_per_off) + geom_histogram(aes(x=n)) +
labs(title = "Figure 1: Distribution of # of Complaints per Officer",
x= "Number of Complaints per Officer", y = "Count")
p1
#number of officers per complaint
off_per_comp <- final_complaints %>% count(complaint_id)
mean(off_per_comp$n)
#what percent of complaints contain more than one officer
more_than_1_perc <- length(which(off_per_comp$n >1))/nrow(off_per_comp)
#distribution of off per comp
p2 <- ggplot(data=off_per_comp) + geom_histogram(aes(x=n)) +
labs(title = "Figure 2: Distribution of # of Officers per Complaint",
x= "Number of Officers per Complaint", y = "Count")
p2
mpd_roster_full_unique <- mpd_roster_full %>%
group_by(ID) %>%
slice(n())
#cleanup workspace
rm(list=setdiff(ls(), c("final_complaints", "mpd_roster_full_unique")))
###
### Create Network of Officers in MPD Roster with Complaints
###
compids = unique(final_complaints$complaint_id)
#create edges of the network (co-named on complaints)
edges = data.frame()
for(j in 1:length(compids)){
# get all officers involved in jth complaint
involved_ids = which(final_complaints$complaint_id==compids[j])
officers = final_complaints$format_name[involved_ids] %>% unique()
# make two-column data frame of each unique combo of officers in the complaint
if (length(officers)>1) {
combos = combn(officers, 2) %>% t() %>% data.frame
} else if (length(officers) == 1) {
combos = data.frame(X1 = officers, X2 = officers)
}
edges = rbind(edges, combos)
}
#create nodes of the network (officers)
nodes <- data.frame(names = unique(c(unique(edges$X1), unique(edges$X2))))
#add officer characteristics
nodes <- left_join(nodes, mpd_roster_full_unique, by = c('names' = 'format_name'))
#create initial visualization of the network
current_network <- igraph::graph_from_data_frame(d=unique(edges),
vertices=nodes, directed = FALSE)
#remove self-loops
current_network <- simplify(current_network, remove.loops = TRUE)
###
### Calculate degree
###
mean(igraph::degree(current_network))
#
# ###
# ### Make interactive visualization based on a provided name
# ###
# # Specify the name of the node you want to highlight
# target_node_name <- "Abdisamad Ahmed"  # Replace with actual node name
#
# # Create a color vector based on node names
# vertex.col <- ifelse(V(current_network)$name == target_node_name,
#                      "red",           # Color for the specific node
#                      "lightblue")     # Default color for other nodes
#
# # Create a size vector based on node names
# vertex.size <- ifelse(V(current_network)$name == target_node_name,
#                       6,              # Larger size for the specific node
#                       4)              # Default size for other nodes
#
# plot(current_network,
#      vertex.color=vertex.col,
#      vertex.size=vertex.size,
#      vertex.label = NA,
#      main = "Officer Rank")
###
### Code for Shiny widget
###
###
### Make this into an interactive visualization
###
library(shiny)
library(colourpicker)
# Define UI
ui <- fluidPage(
titlePanel("Interactive Network Plot"),
sidebarLayout(
sidebarPanel(
selectInput("selected_node",
"Choose a node to highlight:",
choices = NULL,  # Will be populated server-side
selected = NULL),
hr(),
h4("Options:"),
colourInput("highlight_color", "Highlight Color:", value = "#FF0000", showColour = "background"),
colourInput("default_color", "Default Color:", value = "#ADD8E6", showColour = "background"),
numericInput("highlight_size", "Highlight Size:", value = 8, min = 1, max = 20),
numericInput("default_size", "Default Size:", value = 4, min = 1, max = 20),
checkboxInput("color_by_rank", "Color all nodes by Rank", value = FALSE)
),
mainPanel(
plotOutput("network_plot", width = "100%", height = "600px")
)
)
)
# Define Server
server <- function(input, output, session) {
# Build network with name and rank attributes
shiny_network <- reactive({
g <- current_network
V(g)$name <- nodes$names
V(g)$rank <- nodes$JOBTITLE
return(g)
})
# Set fixed layout
network_layout <- reactive({
req(shiny_network())
layout_with_fr(shiny_network())
})
display_name_map <- reactive({
req(shiny_network())
internal <- V(shiny_network())$name
display <- str_to_title(internal)
names(internal) <- display
internal
})
# Update dropdown list of node names (capitalized & sorted)
observe({
req(shiny_network())
node_names <- V(shiny_network())$name
node_names_display <- node_names %>%
tolower() %>%
str_to_title() %>%
sort()
updateSelectInput(session, "selected_node",
choices = node_names_display,
selected = node_names_display[1])
})
# Main network plot
output$network_plot <- renderPlot({
req(shiny_network(), display_name_map())
g <- shiny_network()
layout <- network_layout()
vertex.size <- rep(input$default_size, vcount(g))
vertex.col <- rep(input$default_color, vcount(g))
main_title <- "Network"
# If coloring by rank
if (input$color_by_rank) {
ranks <- V(g)$rank
rank_levels <- unique(ranks)
pal <- viridis::viridis(length(rank_levels), option = "D")
names(pal) <- rank_levels
vertex.col <- pal[as.character(ranks)]
main_title <- "Network Colored by Officer Rank"
}
# If a node is selected, override its color/size
if (!is.null(input$selected_node) && input$selected_node %in% names(display_name_map())) {
selected_internal_name <- display_name_map()[[input$selected_node]]
selected_index <- which(V(g)$name == selected_internal_name)
vertex.col[selected_index] <- input$highlight_color
vertex.size[selected_index] <- input$highlight_size
selected_rank <- V(g)$rank[selected_index]
main_title <- paste0("Highlighting: ", input$selected_node,
" (Rank: ", selected_rank, ")")
}
# Create the plot
plot(g,
vertex.color = vertex.col,
vertex.size = vertex.size,
vertex.label = NA,
main = main_title,
edge.color = "gray",
layout = layout)
# Show rank legend only if coloring by rank
if (input$color_by_rank) {
legend("topleft",
legend = rank_levels,
fill = pal[rank_levels],
border = NA,
bty = "n",
title = "Officer Rank")
}
})
}
# Run the application
shinyApp(ui = ui, server = server)
install.packages('plotly')
# Chunk 1
#start clean
rm(list = ls())
#load libraries
library(tidyverse)
library(igraph)
library(ggraph)
library(here)
library(dplyr)
library(RColorBrewer)
library(readxl)
library(stringdist)
library(viridis)
library(shiny)
library(stringr)
library(ggplot2)
library(plotly)
###
### Formatting and Analysis of Roster Data
###
#read in full roster data, 2023-2025
mpd_roster_full <-
read_csv("data/MPD_roster_2023-2025_Public.csv")
~/Desktop/dspace-qside.github.io/posts/complaint-network/index.qmd
~/Desktop/dspace-qside.github.io/posts/complaint-network/index.qmd
install.packages('rsconnect')
rsconnect::setAccountInfo(name='dspace',
token='09B3AC4FD576B12CDBAB82B61299A3AF',
secret='48fP0/e0Bp/9iyL9QEXCIc+Bi8+zMzvriQQPqvQg')
library(rsconnect)
setwd("~/Desktop/shinyapp")
ls
pwd
library(shiny)
runApp()
library(rsconnect)
deployApp()
runApp()
runApp()
deployApp()
runApp()
deployApp()
shiny::runApp()
runApp()
runApp()
runApp()
deployApp()
library(rsconnect)
deployApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
